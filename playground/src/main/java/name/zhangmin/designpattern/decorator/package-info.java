/**
 * 简介：装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。
 * 属于结构性设计模式中的一种，作为现有类的一个包装类。
 * <p/>
 * 这种设计模式的实现方式是：创建一个装饰类，包装原有的类，并在类
 * 方法签名完整的前提下， 提供额外的功能。
 * <p/>
 * 实现意图：动态给一个对象添加额外的职责。就增加新功能来说， 装饰器模式
 * 相比实现杂类更为灵活。使用继承的方式引入了静态特征， 并且随着扩展功能的
 * 增多，子类会膨胀。
 * <p/>
 * 使用场景：不想增加子类的情况下扩展功能。1）扩展累的功能； 2）动态增加和撤销功能。
 * <p/>
 * 优点：装饰类和被装饰类可以独立发展，不会相互耦合。装饰器模式是继承的一种替代，动态扩展
 * 一个类的实现。
 * <p/>
 * 缺点：多层装饰比较复杂。
 * <p/>
 * 关键代码实现：1）Component充当抽象类角色，不应该有具体的实现；2）修饰类引用和继承Component类，
 * 具体扩展类重写父类方法。
 * @author zhangmin.name
 *
 */
package name.zhangmin.designpattern.decorator;